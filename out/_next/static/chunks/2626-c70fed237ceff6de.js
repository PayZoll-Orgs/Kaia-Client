"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2626],{14124:(e,t,r)=>{r.d(t,{AuthProvider:()=>u,A:()=>h,$:()=>g});var a=r(95155),s=r(12115),n=r(20039),o=r(86867),l=r(87358);class i{static getInstance(){return this.instance||(this.instance=new i),this.instance}save(e){this.storage.set(e.lineUserId,e);let t={...e};return t.privateKey&&(t.privateKey="".concat(t.privateKey.substring(0,6),"...").concat(t.privateKey.substring(-4)," (").concat(t.privateKey.length," chars)")),console.log("\uD83D\uDCBE Saved wallet for dapp ID: ".concat(e.lineUserId),t),console.log("\uD83D\uDD10 Private key included: ".concat(!!e.privateKey)),e}get(e){let t=this.storage.get(e)||null;return console.log("\uD83D\uDD0D Looking up wallet for dapp ID: ".concat(e),t?"✅ Found":"❌ Not found"),t}update(e,t){let r=this.storage.get(e);if(!r)return null;let a={...r,...t,lastUpdated:new Date().toISOString()};return this.storage.set(e,a),console.log("\uD83D\uDCDD Updated wallet for dapp ID: ".concat(e),a),a}delete(e){let t=this.storage.delete(e);return console.log("\uD83D\uDDD1️ Deleted wallet for dapp ID: ".concat(e),t?"✅ Success":"❌ Not found"),t}getAll(){return Array.from(this.storage.values())}clear(){this.storage.clear(),console.log("\uD83E\uDDF9 Cleared all wallet data")}debugShowAll(){console.log("\uD83D\uDCCA Mock Backend Storage Contents:"),0===this.storage.size?console.log("   \uD83D\uDCED No wallets stored"):this.storage.forEach((e,t)=>{let r=!!e.privateKey;console.log("   \uD83D\uDC64 ".concat(t,": ").concat(e.walletAddress," (").concat(e.walletType,") ").concat(r?"\uD83D\uDD10":"\uD83D\uDD13"))})}getPrivateKey(e){let t=this.storage.get(e);return t&&t.privateKey?(console.log("\uD83D\uDD10 Retrieved private key for dapp ID: ".concat(e)),t.privateKey):(console.log("❌ No private key found for dapp ID: ".concat(e)),null)}constructor(){this.storage=new Map,this.storage.set("sample-dapp-id-1",{lineUserId:"sample-dapp-id-1",walletAddress:"0x1234567890123456789012345678901234567890",walletType:"DappPortal",network:"testnet",createdAt:"2024-01-01T00:00:00.000Z",lastUpdated:"2024-01-01T00:00:00.000Z",isActive:!0}),console.log("\uD83D\uDDC4️ Mock wallet storage initialized with sample data")}}l.env.NEXT_PUBLIC_BACKEND_URL;class c{static getInstance(){return this.instance||(this.instance=new c),this.instance}async simulateDelay(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:100;return new Promise(t=>setTimeout(t,e))}async saveWallet(e){await this.simulateDelay();try{let t={lineUserId:e.lineUserId,walletAddress:e.walletAddress,walletType:e.walletType,network:e.network||"testnet",privateKey:e.privateKey,createdAt:new Date().toISOString(),lastUpdated:new Date().toISOString(),isActive:!0},r=this.mockStorage.save(t);return{success:!0,data:r,message:"Wallet saved successfully"}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to save wallet"}}}async getWalletByLineUserId(e){await this.simulateDelay();try{let t=this.mockStorage.get(e);if(t)return{success:!0,data:t,message:"Wallet found"};return{success:!1,error:"Wallet not found",message:"No wallet found for LINE user ID: ".concat(e)}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to get wallet"}}}async getUserWallets(e){await this.simulateDelay();try{let t=this.mockStorage.get(e),r=t?[t]:[];return{success:!0,data:r,message:"Found ".concat(r.length," wallet(s) for user")}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to get user wallets"}}}async updateWallet(e,t){await this.simulateDelay();try{let r=this.mockStorage.update(e,t);if(r)return{success:!0,data:r,message:"Wallet updated successfully"};return{success:!1,error:"Wallet not found",message:"No wallet found for LINE user ID: ".concat(e)}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to update wallet"}}}async deleteWallet(e,t){await this.simulateDelay();try{if(this.mockStorage.delete(e))return{success:!0,message:"Wallet deleted successfully"};return{success:!1,error:"Wallet not found",message:"No wallet found for LINE user ID: ".concat(e)}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to delete wallet"}}}async createAndSaveWallet(e,t,r){try{let a=await this.getWalletByLineUserId(e);if(a.success&&a.data)return this.updateWallet(e,{walletAddress:t,walletType:r,isActive:!0});return this.saveWallet({lineUserId:e,walletAddress:t,walletType:r,network:"testnet"})}catch(e){return console.error("Failed to create and save wallet:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to create and save wallet"}}}debugShowAllWallets(){this.mockStorage.debugShowAll()}async syncWalletData(e,t,r){try{let a=await this.getWalletByLineUserId(e);if(!a.success||!a.data)return this.saveWallet({lineUserId:e,walletAddress:t,walletType:r,network:"testnet"});if(a.data.walletAddress===t)return this.updateWallet(e,{walletType:r,isActive:!0});return this.updateWallet(e,{walletAddress:t,walletType:r,isActive:!0})}catch(e){return console.error("Failed to sync wallet data:",e),{success:!1,error:e instanceof Error?e.message:"Unknown error",message:"Failed to sync wallet data"}}}constructor(){this.mockStorage=i.getInstance()}}let d=(0,s.createContext)(void 0);function u(e){var t;let{children:r}=e,[l,i]=(0,s.useState)({isAuthenticated:!1,isLoading:!0,user:null,friends:[],error:null,isInLineApp:!1}),[u,h]=(0,s.useState)({isConnected:!1,address:null,balance:null,isLoading:!1,error:null,walletType:null}),[g,w]=(0,s.useState)(!1);console.log("\uD83C\uDFAF AuthContext needsOnboarding state:",g);let p=n.l8.getInstance(),f=o.FT.getInstance(),y=c.getInstance(),S=(0,s.useCallback)(async e=>{try{var t;console.log("\uD83D\uDD0D Checking backend for existing wallet for dapp ID:",e),y.debugShowAllWallets();let r=await y.getWalletByLineUserId(e);if(r.success&&(null==(t=r.data)?void 0:t.walletAddress))return console.log("✅ Found existing wallet in backend:",r.data.walletAddress),console.log("\uD83D\uDCA1 User has existing wallet - no onboarding needed"),w(!1),r.data.walletAddress;return console.log("\uD83C\uDFAF No existing wallet found - user needs onboarding"),console.log("\uD83D\uDD04 Setting needsOnboarding to TRUE"),w(!0),null}catch(e){return console.error("❌ Failed to check existing wallet:",e),w(!0),null}},[y]),I=async(e,t)=>{try{console.log("\uD83D\uDCBE Saving wallet to backend...",{lineUserId:e,walletAddress:t});let r=f.getState(),a=await y.saveWallet({lineUserId:e,walletAddress:t,walletType:r.walletType||"Web",network:"testnet"});return a.success?console.log("✅ Wallet saved to backend successfully"):console.error("❌ Failed to save wallet to backend:",a.error),a.success}catch(e){return console.error("❌ Wallet save failed:",e),!1}};(0,s.useEffect)(()=>{let e=p.subscribe(e=>{var t;i(e),e.isAuthenticated&&(null==(t=e.user)?void 0:t.userId)&&!l.isAuthenticated&&(console.log("\uD83D\uDD10 User just authenticated, checking for existing wallet..."),S(e.user.userId))}),t=f.subscribe(e=>{h(e)});return(async()=>{var e;await p.initialize(),await f.initialize(),l.isAuthenticated&&(null==(e=l.user)?void 0:e.userId)&&await S(l.user.userId)})(),()=>{e(),t()}},[p,f,l.isAuthenticated,null==(t=l.user)?void 0:t.userId,S]);let m={isAuthenticated:l.isAuthenticated,isLoading:l.isLoading,user:l.user,friends:l.friends,error:l.error,isInLineApp:l.isInLineApp,wallet:u,needsOnboarding:g,login:async()=>{try{var e;await p.login(),l.isAuthenticated&&(null==(e=l.user)?void 0:e.userId)&&(console.log("\uD83D\uDD10 Login successful, setting up wallet for user:",l.user.userId),await S(l.user.userId))}catch(e){console.error("Login failed:",e)}},logout:()=>{p.logout(),w(!1),f.disconnectWallet().catch(console.error)},clearError:()=>{console.log("Clear error called")},connectWallet:async()=>{try{var e;let t=await f.connectWallet();return t&&(null==(e=l.user)?void 0:e.userId)&&(await I(l.user.userId,t),g&&(console.log("\uD83C\uDFAF Wallet created during onboarding - marking onboarding as completed"),w(!1))),t}catch(e){throw console.error("Wallet connection failed:",e),e}},disconnectWallet:async()=>{try{await f.disconnectWallet()}catch(e){throw console.error("Wallet disconnection failed:",e),e}},signMessage:async e=>{try{return await f.signMessage(e)}catch(e){throw console.error("Message signing failed:",e),e}},connectAndSign:async e=>{try{return await f.connectAndSign(e)}catch(e){throw console.error("Connect and sign failed:",e),e}},refreshWalletData:async()=>{try{await f.refreshWalletData()}catch(e){throw console.error("Refresh wallet data failed:",e),e}},sendTransaction:async(e,t,r)=>{try{return await f.sendTransaction(e,t,r)}catch(e){throw console.error("Transaction failed:",e),e}},getTokenBalance:async e=>{try{return await f.getTokenBalance(e)}catch(e){throw console.error("Get token balance failed:",e),e}},completeOnboarding:()=>{console.log("\uD83C\uDF89 Onboarding completed!"),w(!1)},handleOAuthCallback:async(e,t)=>{p&&await p.handleOAuthCallback(e,t)}};return(0,a.jsx)(d.Provider,{value:m,children:r})}function h(){let e=(0,s.useContext)(d);if(void 0===e)throw Error("useAuth must be used within an AuthProvider");return e}function g(){let{handleOAuthCallback:e}=h();return{handleCallback:e}}},20039:(e,t,r)=>{r.d(t,{Oi:()=>l,l8:()=>d});var a=r(34590);let s={clientId:"2008104363",redirectUri:"https://6c55ac586a0e.ngrok-free.app/auth/callback",liffId:"2008104363-1l9GzPkZ",scope:"profile openid",authUrl:"https://access.line.me/oauth2/v2.1/authorize",tokenUrl:"https://api.line.me/oauth2/v2.1/token",profileUrl:"https://api.line.me/v2/profile",friendsUrl:"https://api.line.me/friendship/v1/friends"};function n(e){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",r=new Uint8Array(e);crypto.getRandomValues(r);let a="";for(let s=0;s<e;s++)a+=t[r[s]%t.length];return a}async function o(e){let t=new TextEncoder().encode(e),r=await crypto.subtle.digest("SHA-256",t);return btoa(String.fromCharCode.apply(null,Array.from(new Uint8Array(r)))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}class l{static async initialize(){if(this.initialized)return!0;try{return await a.M.init({liffId:s.liffId}),this.initialized=!0,!0}catch(e){return console.error("LIFF initialization failed:",e),!1}}static isInLineApp(){try{return a.M.isInClient()}catch(e){return!1}}static isLoggedIn(){try{return a.M.isLoggedIn()}catch(e){return!1}}static async login(){try{a.M.isLoggedIn()||a.M.login()}catch(e){throw e}}static async getProfile(){try{let e=await a.M.getProfile();return{userId:e.userId,displayName:e.displayName,pictureUrl:e.pictureUrl,statusMessage:e.statusMessage}}catch(e){throw e}}static async getFriends(){try{return[]}catch(e){throw e}}static logout(){try{a.M.logout()}catch(e){}}static async scanQRCode(){try{let e=await a.M.scanCodeV2();return(null==e?void 0:e.value)||null}catch(e){if(console.error("LIFF QR scan error:",e),"CANCEL"===e.code)return null;throw e}}static canScanQRCode(){try{return a.M.isInClient()}catch(e){return!1}}}l.initialized=!1;class i{static async generateLoginUrl(){let e=n(32),t=n(32),r=n(128);sessionStorage.setItem("line_auth_state",e),sessionStorage.setItem("line_auth_nonce",t),sessionStorage.setItem("line_code_verifier",r);let a=await o(r),l=new URLSearchParams({response_type:"code",client_id:s.clientId,redirect_uri:s.redirectUri,state:e,scope:s.scope,nonce:t,code_challenge:a,code_challenge_method:"S256"});return"".concat(s.authUrl,"?").concat(l.toString())}static async exchangeCodeForToken(e){let t=sessionStorage.getItem("line_code_verifier");if(!t)throw Error("Code verifier not found. Please restart the login process.");let r=new URLSearchParams({grant_type:"authorization_code",code:e,redirect_uri:s.redirectUri,client_id:s.clientId,code_verifier:t});try{let e=await fetch(s.tokenUrl,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:r});if(!e.ok){let t=await e.text(),r={};try{r=JSON.parse(t)}catch(e){}throw Error("Token exchange failed: ".concat(e.status," - ").concat(r.error_description||r.error||t))}let t=await e.json();return sessionStorage.removeItem("line_code_verifier"),sessionStorage.removeItem("line_auth_nonce"),t}catch(e){throw e}}static async getProfile(e){try{let t=await fetch(s.profileUrl,{headers:{Authorization:"Bearer ".concat(e)}});if(!t.ok)throw Error("Profile fetch failed: ".concat(t.status));let r=await t.json();return{userId:r.userId,displayName:r.displayName,pictureUrl:r.pictureUrl,statusMessage:r.statusMessage}}catch(e){throw e}}static async getFriends(e){try{var t;let r=await fetch(s.friendsUrl,{headers:{Authorization:"Bearer ".concat(e)}});if(console.log("This is the response",r),!r.ok)return[];return(null==(t=(await r.json()).friends)?void 0:t.map(e=>({userId:e.userId,displayName:e.displayName,pictureUrl:e.pictureUrl,statusMessage:e.statusMessage})))||[]}catch(e){return[]}}}class c{static saveUser(e){localStorage.setItem(this.USER_KEY,JSON.stringify(e))}static getUser(){try{let e=localStorage.getItem(this.USER_KEY);return e?JSON.parse(e):null}catch(e){return null}}static saveFriends(e){localStorage.setItem(this.FRIENDS_KEY,JSON.stringify(e))}static getFriends(){try{let e=localStorage.getItem(this.FRIENDS_KEY);return e?JSON.parse(e):[]}catch(e){return[]}}static saveTokens(e,t){localStorage.setItem(this.ACCESS_TOKEN_KEY,e),t&&localStorage.setItem(this.REFRESH_TOKEN_KEY,t)}static getAccessToken(){return localStorage.getItem(this.ACCESS_TOKEN_KEY)}static getRefreshToken(){return localStorage.getItem(this.REFRESH_TOKEN_KEY)}static clear(){localStorage.removeItem(this.USER_KEY),localStorage.removeItem(this.FRIENDS_KEY),localStorage.removeItem(this.ACCESS_TOKEN_KEY),localStorage.removeItem(this.REFRESH_TOKEN_KEY)}}c.USER_KEY="line_user",c.FRIENDS_KEY="line_friends",c.ACCESS_TOKEN_KEY="line_access_token",c.REFRESH_TOKEN_KEY="line_refresh_token";class d{static getInstance(){return this.instance||(this.instance=new d),this.instance}subscribe(e){return this.listeners.push(e),()=>{this.listeners=this.listeners.filter(t=>t!==e)}}notifyListeners(){this.listeners.forEach(e=>e(this.authState))}updateState(e){this.authState={...this.authState,...e},this.notifyListeners()}getState(){return{...this.authState}}async initialize(){this.updateState({isLoading:!0,error:null});try{let e=await l.initialize(),t=l.isInLineApp();this.updateState({isInLineApp:t});let r=null,a=[];e&&t&&l.isLoggedIn()?(r=await l.getProfile(),a=await l.getFriends(),c.saveUser(r),c.saveFriends(a)):(r=c.getUser(),a=c.getFriends()),this.updateState({isAuthenticated:!!r,user:r,friends:a,isLoading:!1})}catch(e){this.updateState({isAuthenticated:!1,user:null,friends:[],isLoading:!1,error:e instanceof Error?e.message:"Authentication failed"})}}async login(){this.updateState({isLoading:!0,error:null});try{if(this.authState.isInLineApp){await l.login();let e=await l.getProfile(),t=await l.getFriends();c.saveUser(e),c.saveFriends(t),this.updateState({isAuthenticated:!0,user:e,friends:t,isLoading:!1})}else{let e=await i.generateLoginUrl();window.location.href=e}}catch(e){this.updateState({isLoading:!1,error:e instanceof Error?e.message:"Login failed"})}}async handleOAuthCallback(e,t){this.updateState({isLoading:!0,error:null});try{let r=sessionStorage.getItem("line_auth_state");if(t!==r)throw Error("Invalid state parameter - possible CSRF attack");let a=await i.exchangeCodeForToken(e),s=await i.getProfile(a.access_token),n=await i.getFriends(a.access_token);c.saveUser(s),c.saveFriends(n),c.saveTokens(a.access_token,a.refresh_token),sessionStorage.removeItem("line_auth_state"),this.updateState({isAuthenticated:!0,user:s,friends:n,isLoading:!1})}catch(e){this.updateState({isAuthenticated:!1,user:null,friends:[],isLoading:!1,error:e instanceof Error?e.message:"Authentication failed"})}}logout(){c.clear(),this.authState.isInLineApp&&l.logout(),this.updateState({isAuthenticated:!1,user:null,friends:[],error:null})}constructor(){this.authState={isAuthenticated:!1,isLoading:!0,user:null,friends:[],error:null,isInLineApp:!1},this.listeners=[]}}},33275:(e,t,r)=>{r.d(t,{A:()=>s});var a=r(95155);function s(e){let{message:t="Loading..."}=e;return(0,a.jsx)("div",{className:"min-h-screen flex items-center justify-center bg-gray-50",children:(0,a.jsxs)("div",{className:"text-center",children:[(0,a.jsx)("div",{className:"w-16 h-16 mx-auto mb-4 bg-green-100 rounded-full flex items-center justify-center",children:(0,a.jsx)("div",{className:"w-8 h-8 border-4 border-green-500 border-t-transparent rounded-full animate-spin"})}),(0,a.jsx)("h2",{className:"text-xl font-semibold text-gray-900 mb-2",children:"Loading..."}),(0,a.jsx)("p",{className:"text-gray-500",children:t})]})})}r(12115)},86867:(e,t,r)=>{r.d(t,{FT:()=>o,S4:()=>s,s1:()=>n});let a=null;Promise.all([r.e(4550),r.e(2121),r.e(716)]).then(r.bind(r,33298)).then(e=>{a=e.default}).catch(console.error);var s=function(e){return e.Web="Web",e.Liff="Liff",e.Extension="Extension",e.Mobile="Mobile",e.OKX="OKX",e.BITGET="BITGET",e}({});let n="0xd077a400968890eacc75cdc901f0356c943e4fdb";class o{static getInstance(){return this.instance||(this.instance=new o),this.instance}static async initializeDappPortalSDK(){if(this.sdkInitialized&&this.sdkInstance)return console.log("\uD83D\uDD04 Using existing DappPortal SDK singleton instance"),this.sdkInstance;console.log("\uD83D\uDE80 Initializing DappPortal SDK singleton for Kaia testnet...");let e="feab7d6b-52d3-4568-ab0f-ad72c35fe884";if(console.log("\uD83D\uDD0D SDK Initialization params:"),console.log("  - CLIENT_ID provided:",!!e),console.log("  - CLIENT_ID value:",e||"NOT_SET"),console.log("  - CLIENT_ID length:",e.length||0),console.log("  - Chain ID: 1001 (Kaia testnet)"),!e)throw console.error("\uD83D\uDEAB Invalid CLIENT_ID detected!"),console.error("   Current value:",e),console.error("   This will likely cause wallet provider to be null"),Error("Invalid CLIENT_ID configuration");try{if(!a){let{default:e}=await Promise.all([r.e(4550),r.e(2121),r.e(716)]).then(r.bind(r,33298));a=e}return this.sdkInstance=await a.init({clientId:e,chainId:"1001"}),this.sdkInitialized=!0,console.log("✅ DappPortal SDK singleton initialized successfully"),console.log("\uD83D\uDD0D SDK instance:",!!this.sdkInstance),console.log("\uD83D\uDD0D SDK methods available:",Object.getOwnPropertyNames(this.sdkInstance)),this.sdkInstance}catch(t){throw console.error("❌ DappPortal SDK singleton initialization failed:",t),console.error("\uD83D\uDD0D Error details:"),console.error("  - Error type:",typeof t),console.error("  - Error message:",t instanceof Error?t.message:"Unknown error"),console.error("  - Error stack:",t instanceof Error?t.stack:"No stack trace"),t instanceof Error&&t.message.includes("CLIENT_ID not authorized")&&(console.error("\uD83D\uDEAB AUTHORIZATION ERROR: Your DApp Portal CLIENT_ID is not authorized for wallet operations"),console.error("\uD83D\uDCCB SOLUTION: Check your LINE Next DApp Portal registration"),console.error("   1. Go to: https://dapp-portal.line.me/"),console.error("   2. Verify CLIENT_ID:",e),console.error("   3. Ensure Kaia testnet is enabled"),console.error("   4. Check wallet operations permissions")),this.sdkInitialized=!1,this.sdkInstance=null,t}}static resetSDKSingleton(){console.log("\uD83D\uDD04 Resetting DappPortal SDK singleton"),this.sdkInstance=null,this.sdkInitialized=!1}static getSDKInstance(){return this.sdkInstance}subscribe(e){return this.listeners.push(e),()=>{this.listeners=this.listeners.filter(t=>t!==e)}}notifyListeners(){this.listeners.forEach(e=>e(this.walletState))}updateState(e){this.walletState={...this.walletState,...e},this.notifyListeners()}getState(){return{...this.walletState}}async initialize(){this.updateState({isLoading:!0,error:null}),console.warn("initialize wallet called");try{let e=await o.initializeDappPortalSDK();console.log("\uD83D\uDD0D Getting wallet provider from singleton SDK..."),this.walletProvider=e.getWalletProvider(),console.log("\uD83D\uDD0D Wallet provider received:",!!this.walletProvider),console.warn("\uD83D\uDD0D Wallet provider",this.walletProvider);try{if(!this.walletProvider)return console.warn("⚠️ Wallet provider is null - skipping connection check"),this.updateState({isLoading:!1}),console.log("SDK initialized but no provider available yet"),!0;console.log("\uD83D\uDD0D Checking for existing wallet connections...");let e=await this.walletProvider.request({method:"kaia_accounts"});if(e&&e.length>0){let t=e[0],r=this.walletProvider.getWalletType();console.log("\uD83D\uDD0D Wallet type:",r);let a=await this.getBalance(t);console.log("✅ Found existing wallet connection:",t),this.updateState({isConnected:!0,address:t,balance:a,walletType:r,isLoading:!1})}else console.log("ℹ️ No existing wallet connection found"),this.updateState({isLoading:!1})}catch(e){console.log("ℹ️ No wallet connected yet"),this.updateState({isLoading:!1})}return!0}catch(e){return console.error("❌ Wallet service initialization failed:",e),console.error("\uD83D\uDD0D Wallet service initialization error details:"),console.error("  - Error type:",e instanceof Error?e.constructor.name:typeof e),console.error("  - Error message:",e instanceof Error?e.message:String(e)),console.error("  - SDK singleton initialized:",o.sdkInitialized),console.error("  - SDK singleton instance:",!!o.sdkInstance),e instanceof Error&&(e.message.includes("403")||e.message.includes("Forbidden"))&&(console.error("\uD83D\uDEAB Authorization failed - CLIENT_ID may be invalid or not authorized"),console.error("\uD83D\uDCCB Get valid CLIENT_ID from: https://docs.dappportal.io/mini-dapp/mini-dapp-sdk/how-to-get-sdk-authorization")),this.updateState({isLoading:!1,error:e instanceof Error?e.message:"Initialization failed"}),!1}}async connectWallet(){if(!this.walletProvider)throw Error("Wallet provider not initialized");this.updateState({isLoading:!0,error:null}),console.log("\uD83D\uDD17 Requesting wallet connection..."),console.log("\uD83D\uDCA1 If user has no wallet, DappPortal will show wallet creation UI");try{let e=await this.walletProvider.request({method:"kaia_requestAccounts"});if(!e||0===e.length)throw Error("No accounts returned from wallet - user may have cancelled");let t=e[0],r=this.walletProvider.getWalletType();console.log("✅ Wallet connected successfully:",t),console.log("\uD83D\uDD0D Wallet type:",r),await this.verifyTestnetConnection();let a=await this.getBalance(t);return this.updateState({isConnected:!0,address:t,balance:a,walletType:r,isLoading:!1}),t}catch(t){console.error("❌ Wallet connection failed:",t);let e="Wallet connection failed";throw t instanceof Error&&(e=t.message.includes("User denied")||t.message.includes("cancelled")?"User cancelled wallet connection":t.message.includes("No accounts")?"No wallet accounts available - please create a wallet first":t.message),this.updateState({isLoading:!1,error:e}),t}}async verifyTestnetConnection(){if(this.walletProvider)try{let e=window.klaytn;if(e&&e.networkVersion){let t=e.networkVersion;"1001"!==t&&console.warn("Connected to network ".concat(t,", expected 1001 (Kairos testnet)"))}}catch(e){console.warn("Could not verify network connection:",e)}}async getBalance(e){if(!this.walletProvider)throw Error("Wallet provider not initialized");let t=e||this.walletState.address;if(!t)throw Error("No wallet address available");try{let e=await this.walletProvider.request({method:"kaia_getBalance",params:[t,"latest"]}),r=BigInt(e);return(Number(r)/1e18).toFixed(6)}catch(e){return console.error("Failed to get balance:",e),"0.000000"}}async getTokenBalance(e,t){if(!this.walletProvider)throw Error("Wallet provider not initialized");let r=t||this.walletState.address;if(!r)throw Error("No wallet address available");try{let t=await this.walletProvider.getErc20TokenBalance(e,r);if(e.toLowerCase()===n.toLowerCase()){let e=BigInt(t);return(Number(e)/1e6).toFixed(2)}let a=BigInt(t);return(Number(a)/1e18).toFixed(6)}catch(e){return console.error("Failed to get token balance:",e),"0.00"}}async connectAndSign(e){if(!this.walletProvider)throw Error("Wallet provider not initialized");this.updateState({isLoading:!0,error:null});try{let[t,r]=await this.walletProvider.request({method:"kaia_connectAndSign",params:[e]}),a=this.walletProvider.getWalletType();console.log("\uD83D\uDD0D Wallet type:",a);let s=await this.getBalance(t);return this.updateState({isConnected:!0,address:t,balance:s,walletType:a,isLoading:!1}),{account:t,signature:r}}catch(e){throw console.error("Connect and sign failed:",e),this.updateState({isLoading:!1,error:e instanceof Error?e.message:"Connect and sign failed"}),e}}async signMessage(e){if(!this.walletProvider||!this.walletState.address)throw Error("Wallet not connected");try{return await this.walletProvider.request({method:"personal_sign",params:[e,this.walletState.address]})}catch(e){throw console.error("Message signing failed:",e),e}}async sendTransaction(e,t,r){if(!this.walletProvider||!this.walletState.address)throw Error("Wallet not connected");try{let a={from:this.walletState.address,to:e,value:t,gas:r||"0x5208"};return await this.walletProvider.request({method:"kaia_sendTransaction",params:[a]})}catch(e){throw console.error("Transaction failed:",e),e}}async disconnectWallet(){if(this.walletProvider)try{await this.walletProvider.disconnectWallet(),this.updateState({isConnected:!1,address:null,balance:null,walletType:null,error:null})}catch(e){console.error("Wallet disconnection failed:",e),this.updateState({error:e instanceof Error?e.message:"Wallet disconnection failed"})}}async refreshWalletData(){if(this.walletState.isConnected&&this.walletState.address){this.updateState({isLoading:!0});try{let e=await this.getBalance();this.updateState({balance:e,isLoading:!1})}catch(e){console.error("Failed to refresh wallet data:",e),this.updateState({isLoading:!1,error:e instanceof Error?e.message:"Failed to refresh wallet data"})}}}async getCurrentConnectedWallet(){if(!this.walletProvider)return{address:null,walletType:null,error:"Wallet provider not initialized"};try{let e=await this.walletProvider.request({method:"kaia_accounts"});if(e&&e.length>0)return console.log("Found current connected wallet:",e[0]),{address:e[0],walletType:this.walletProvider.getWalletType(),source:"current"};return{address:null,walletType:null,source:"none",error:"No wallet currently connected"}}catch(e){return console.error("Failed to get current connected wallet:",e),{address:null,walletType:null,source:"none",error:e instanceof Error?e.message:"SDK error"}}}async getWalletByLineUserId(e){return console.warn("⚠️  SDK LIMITATION: DappPortal SDK cannot retrieve wallet by LINE user ID"),console.warn("⚠️  The SDK only works with currently connected wallets"),console.warn("⚠️  For persistent wallet-user mapping, backend storage is required"),{...await this.getCurrentConnectedWallet(),needsBackend:!0}}async hasExistingWallet(e){try{let t=await this.getWalletByLineUserId(e);return null!==t.address}catch(e){return console.error("Failed to check existing wallet:",e),!1}}constructor(){this.walletProvider=null,this.walletState={isConnected:!1,address:null,balance:null,isLoading:!1,error:null,walletType:null},this.listeners=[]}}o.sdkInstance=null,o.sdkInitialized=!1}}]);